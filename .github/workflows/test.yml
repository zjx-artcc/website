name: Run Tests in Docker

on:
  push:
    branches: [ "**" ]
  pull_request:
    branches: [ "master", "develop" ]

jobs:
  test-in-docker:
    # Works on 'ubuntu-latest' OR 'self-hosted'
    runs-on: ubuntu-latest 
    
    steps:
      - uses: actions/checkout@v4

      # 1. Create the .env file for Docker Compose
      # Even though we are testing, Docker Compose needs this file to 
      # populate the variables in your YAML (like ${DB_USERNAME})
      - name: Setup Test Environment
        run: |
          echo "${{ secrets.TESTING_ENV_FILE }}" > .env.testing

      # 2. Build the Stack (CRITICAL: Enable Dev Tools)
      # We pass INSTALL_DEV=true so Composer includes PHPUnit/Pest
      - name: Build Containers
        run: |
          docker compose -f deploy/docker-compose.yml build \
            --build-arg INSTALL_DEV=true

      # 3. Start the Stack
      - name: Start Services
        run: docker compose --env-file .env.testing -f deploy/docker-compose.yml up -d

      # 4. Wait for Database
      # We use the healthcheck you already defined in docker-compose.yml
      - name: Wait for DB Health
        run: |
          echo "Waiting for database to become healthy..."
          timeout 60s sh -c 'until docker inspect --format="{{.State.Health.Status}}" deploy-db-1 | grep -q "healthy"; do sleep 2; done'

      # 5. Run the Tests INSIDE the container
      - name: Execute Tests
        run: |
          # Use -T to disable TTY interaction (prevents errors in CI)
          docker compose -f deploy/docker-compose.yml exec -T laravel sh -c "
            php artisan key:generate &&
            php artisan migrate:fresh --force --seed &&
            php artisan test
          "

      # 6. Cleanup
      # Always run this to remove the containers and the testing volume
      - name: Teardown
        if: always()
        run: docker compose -f deploy/docker-compose.yml down -v